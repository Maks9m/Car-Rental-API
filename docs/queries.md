# Документація складних запитів

Тут описані аналітичні запити, реалізовані в системі, їх бізнес-значення та SQL-реалізація.

### Запит 1: Рейтинг активності та прибутковості користувачів

**Бізнес-питання:**
Хто є нашими найціннішими клієнтами? Необхідно ранжувати користувачів на основі двох факторів:
1. Кількість успішних бронювань (активність).
2. Загальна сума витрачених коштів (прибутковість).

Це дозволяє відділу маркетингу виділяти VIP-клієнтів для програм лояльності.

**SQL-запит (генерований SQLAlchemy):**

```sql
SELECT
    "user".user_id,
    "user".firstname,
    "user".lastname,
    COUNT(booking.booking_id) AS total_bookings,
    COALESCE(SUM(payment.amount), 0) AS total_spent,
    DENSE_RANK() OVER (
        ORDER BY 
            COUNT(booking.booking_id) DESC, 
            COALESCE(SUM(payment.amount), 0) DESC
    ) as rank
FROM "user"
JOIN booking ON "user".user_id = booking.user_id
JOIN trip ON booking.booking_id = trip.booking_id
JOIN payment ON trip.trip_id = payment.trip_id
WHERE booking.status != 'CANCELED'
GROUP BY "user".user_id, "user".firstname, "user".lastname
ORDER BY rank;
```

### Пояснення логіки запиту

Цей запит реалізує комплексну аналітику для побудови рейтингу користувачів. Логіка складається з наступних кроків:

1.  **Об'єднання даних (JOINs):**
    * Ми починаємо з таблиці `user` і послідовно приєднуємо:
        * `booking` (за `user_id`): щоб знайти всі замовлення користувача.
        * `trip` (за `booking_id`): щоб підтвердити, що бронювання перетворилося на реальну поїздку.
        * `payment` (за `trip_id`): щоб отримати фінансові дані про кожну поїздку.

2.  **Фільтрація даних:**
    * `WHERE booking.status != 'CANCELED'`: Ми свідомо виключаємо скасовані замовлення. Рейтинг має базуватися лише на реальних, успішних взаємодіях. Скасовані бронювання не додають цінності бізнесу, тому не впливають на ранг.

3.  **Обробка відсутності даних (COALESCE):**
    * `COALESCE(SUM(payment.amount), 0)`: Це критично важливий момент. Якщо користувач має бронювання, але ще не здійснив оплат (або дані про оплату відсутні), звичайна функція `SUM` повернула б `NULL`. Це зламало б сортування. `COALESCE` гарантує, що в такому випадку ми отримаємо `0.00`, що дозволяє коректно порівнювати всіх користувачів.

4.  **Розрахунок рангу (Window Function):**
    * Ми використовуємо віконну функцію `DENSE_RANK()`, а не звичайний `RANK()`.
    * **Чому?** Якщо два користувачі мають однакові показники (наприклад, по 10 поїздок і 5000 грн витрат), вони обидва отримають ранг #1. При використанні `DENSE_RANK`, наступний користувач буде #2. Якби ми використали `RANK`, наступний був би #3 (пропуск рангу). Для бізнес-звітів "щільне" ранжування зазвичай є більш зрозумілим.
    * **Пріоритет:** Сортування відбувається спочатку за кількістю бронювань (активність), а потім за сумою витрат (прибутковість).

5.  **Групування:**
    * Результати групуються за унікальним ідентифікатором користувача (`user_id`), а також його ім'ям та прізвищем, щоб вивести агреговану статистику для кожної особи окремо.

### Приклад виводу

Результат виконання запиту повертає таблицю з ранжованим списком користувачів.

| user_id | firstname | lastname   | total_bookings | total_spent | rank |
|---------|-----------|------------|----------------|-------------|------|
| 10      | Ivan      | Petrenko   | 15             | 12500.00    | 1    |
| 4       | Maria     | Koval      | 12             | 8400.50     | 2    |
| 7       | John      | Doe        | 12             | 8100.00     | 3    |
| 2       | Alex      | Smith      | 5              | 2000.00     | 4    |
| 8       | Olena     | Sydorenko  | 3              | 0.00        | 5    |

**Аналіз результату:**
1.  **Ivan Petrenko** займає 1-ше місце, бо має найбільшу кількість бронювань (15).
2.  **Maria Koval** та **John Doe** мають однакову кількість бронювань (12), тому система порівнює їх за сумою витрат. Maria витратила більше (8400.50 проти 8100.00), тому вона на 2-му місці, а John — на 3-му.
3.  **Olena Sydorenko** потрапила в рейтинг навіть без витрат (`0.00`), але з нижчим рангом.
